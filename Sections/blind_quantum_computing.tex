%
% Encrypted Cloud Quantum Computation
%


\section{Blind quantum computation} \label{sec:blind} \index{Encrypted quantum computation}

\sectionby{(in progress..)}

\dropcap{I}{magine} a scenario where a computationally weak client wishes to delegate his/her desired computation to a remote server. The delegation is performed in such a way that the privacy of the client's computation is preserved even from the server implementing the computation. We divide the literature that studies this task of the secure delegation of (classical or quantum) computation depending on the resources available at the client's and the server's side. They are mainly broadly divided into three categories: a) classical client and classical server, b) classical client and quantum server(s), and c) semi-classical client and quantum server(s). Before going into the details of the these categories we first discuss the relevant security criterion for a delegated protocol. 
%%security 
\subsection{Security Definitions}
The security of delegated computing protocols consists of two aspects: a) blindness and b) verification. The property of blindness deals with the privacy of the client's computation as well as the input and the output from the server. The verification property ensures the correctness of the client's computation. We provide a formal definition of blindness and verification in the client-server setting using the stand-alone and the composable framework. For details on composable security of delegated protocols, we refer the interested reader to \cite{dunjko2014composable}. This chapter primarily deals with the blindness of the cloud quantum computing. In the next chapter, we elaborate more on the verification aspect of the (delegated) quantum computation 

%%%change these definitions...
\begin{definition}[Stand-alone blindness]
\label{def:secbqc}
Let $\mathcal{P}$ be a quantum delegated computation protocol, between a client and a server, on input $X$ and let $L(X)$ be any function of the input. We say that $P$ is blind while leaking at most $L(X)$ if, on the client's input
$X$, for any  fixed $Y = L(X)$, the following two conditions hold when given $Y$:
\begin{enumerate}
\item The distribution of the classical information obtained by the server in $P$ is independent of $X$.
\item Given the classical information described in 1 (i.e. given a sample from the distribution of classical information), the state of the quantum system obtained by the server in $P$ is fixed and independent of $X$.
\end{enumerate}
\end{definition}

\textcolor{blue}{ADD composable definitions of Blindness in the abstract cryptography framework}
\subsection{Client-server complexity} 

\subsubsection{Classical client - classical server}%%%%%% CC
Consider a setting that involves two parties - Alice and Bob. Alice has an input $x$, which is an instance of a function $f$, and she wishes to obtain an answer by implementing the function $f$ on that input. Alice is computationally weak, therefore she would like to delegate this task to a computationally powerful party, Bob. Although Bob is willing to help Alice to evaluate $f(x)$, she doesn't trust him. One possible solution is for Alice to encrypt her message and ask Bob to compute the function in such a way that she can decrypt back Bob's reply to obtain her desired result. 

This notion of computing with encrypted data (in the information theoretic setting) was first introduced by Feigenbaum in~\cite{feigenbaum1985encrypting}, where the function $f$ is called \emph{encryptable} if (roughly speaking) the following conditions hold: 
\begin{enumerate}
\item Alice is able to transform an instance of $f$ \textit{i.e.} $x$ in to another instance $x'$ of $f$. 
\item Bob has the ability to perform the computation $f$ on $x'$ and send the result $f(x')$ to Alice.
\item Alice can transform $f(x')$ to $f(x)$ given her weak computational resources. 
\item Bob cannot infer $x'$ from $x$.  
\end{enumerate} 
For example, a protocol that encrypts instances of discrete logarithm problem would satisfy the above conditions and is called encryptable. On the other hand, encrypting instances of clique problem does not satisfy all the conditions at the same time. 
%%% Abadi et al.. extending it to GES and client-server setting 
Extending the result of Feigenbaum, an important no-go result was given by Abadi, Feigenbaum, and Killian in~\cite{abadi1987hiding}.  They extended the above two-party scheme to the realm of the client-server scenario by providing a generalized encryption scheme (GES), where in addition to the conditions listed for encrypting problem instances, a client is allowed to interact in the polynomial number of rounds with the server. Moreover, the client only requires that the computation results in the correct outcome with a probability $\frac{1}{2} + \epsilon$, where $\epsilon$ can be inversely proportional to the size of the input.  They observed that any function $f$ evaluated using this GES scheme is contained in the complexity class $\text{NP/poly} \cap \text{coNP/poly}$ essentially showing that no NP-hard function can be computed with encrypted data unless the polynomial hierarchy collapses \footnote{\textcolor{blue}{Write about the PH collapse...}} at the third level.
%%%% computational security..
In the setting of computational security, the problem of computing on encrypted data was first considered by Rivest, Adleman and Dertouzos~\cite{rivest1978data}, which then led to the development of homomorphic encryption and eventually to fully homomorphic encryption with Gentry's scheme~\cite{gentry2009fully}.  For more details on this topic, we refer the readers to a recent survey~\cite{peikert2016decade}.

The main difference in the setting of fully homomorphic encryption and the task of encrypting problem instances or GES is that the protocols in the former setting are mostly based on the intractability assumptions while the latter one puts no assumption on the adversarial power of the server. Also, GES allows a polynomial number of round of interaction between the client and the server. From here onwards, we always refer to Alice as the client and Bob as the server. 

The large-scale quantum computers would potentially offer extreme computational advantages over conventional computing technologies for a range of problems spanning cryptanalysis~\cite{shor1999polynomial}, simulation of physical systems~\cite{lloyd1996universal}, and machine learning~\cite{biamonte2017quantum}.  With the recent advancement in quantum cloud services \cite{IBM2016, Rigetti2017}, it is very likely that the first universal quantum computer would take a similar role to that of today's supercomputers and likely be hosted only by major institutions. A client wishing to use one may have to rely on these cloud-based quantum servers, where data are stored and manipulated at a remote site. Therefore, it is reasonable to extend the set of classical client - classical server to the case where a classical client would like to perform secure delegation of quantum computation with the help of a quantum server. (To DO: relate to the quantum internet!)
 

\subsubsection{Classical client - quantum server}
%%CQ
Consider the task of delegated quantum computing with a completely classical client. Ideally, we would like a delegation scheme for a classical client and a quantum server to satisfy the following requirements:
\begin{enumerate}
\item[CQ1.] (Universality) The client should be able to delegate an arbitrary quantum computation. 
\item[CQ2.] (Interaction) The number of rounds of interaction between the client and the server should not exceed polynomial in the length of the client's input size.
\item[CQ3.] (Security)  The protocol should not leak any information about the computation and/or the input and the output except (at most) the circuit dimensions.
\item[CQ4.] (Type of security) The protocol should have information-theoretic security, where the adversary can be computationally unbounded, and possibly composable secure. 
\end{enumerate}
Note: I have not added verification here assuming it is covered in the next section. Otherwise we modify the CQ3 requirement here to incorporate verification as well!

The possibility of securely delegating a quantum computation to a quantum server was first considered by Morimae and Koshiba ~\cite{morimae2014impossibility}.  They showed a negative result by presenting a  \emph{scheme-dependent} impossibility proof.  The authors considered a scenario where a classical user and a quantum server exchange classical information in a two-step process. First, the classical client encodes their description of the computation using an affine encryption scheme and then sends all the classical encrypted data to the server. The server then performs a quantum computation using the received data and returns the classical output to the client who decrypts the result using their encryption key. For this setting, it was shown that secure blind quantum computing cannot be achieved unless $\text{BPP} = \text{BQP}$ (\textit{i.e.},~unless a classical computer can efficiently simulate a quantum computer). While this is an interesting result, it imposes strong assumptions on the operational method of the delegation scheme with a classical client. Specifically, the scheme only allows a single round of interaction and doesn't allow even the circuit dimension to be leaked. Further, the generalized encryption scheme (GES) of Abadi et al.~\cite{abadi1987hiding} has also been considered for the class of functions solvable by a quantum computer in~\cite{dunjko2016blind, aaronson2017implausibility}. Specifically, Ref.~\cite{aaronson2017implausibility} provides an implausibility result of a GES for BQP functions under the complexity-theoretic assumptions by showing that GES for BQP-hard functions leads to $\text{BQP} \subset \text{NP/poly} \cap \text{coNP/poly}$. Such containment is not known to be equivalent or reducible to polynomial hierarchy collapse. However, by relaxing the condition [CQ2] to allow the interaction between the client and the server bounded by a polynomial of fixed degree, they presented an oracle relative to which a classical client is not able to delegate the universal quantum computation using the GES encryption scheme.

On the positive side, in a recent breakthrough result by Mahadev~\cite{mahadev2017classical}, the condition [CQ4] is relaxed to present a scheme for delegation of quantum computation for a completely classical client. The result, assuming certain quantum-secure one-way functions exist, shows that a classical client is able to securely delegate an arbitrary quantum computation under the assumption of post-quantum computational security. Moreover, the required interaction is only single round between the client and the server. Under similar computational security assumptions, the possibility of secure delegation of quantum computation for a classical client is also shown in~\cite{cojocaru2018delegated} and security is shown for the quantum-honest-but-curious setting $\textit{i.e.}$ in restricted adversarial scenarios.  In Part I of this dissertation, we study the problem of secure delegation of quantum computation for a completely classical client and show some of our results by relaxing the condition [CQ1] and [CQ3] to a certain level and show some possibility results in this direction.  

None of the proposed delegated quantum computing schemes so far satisfy all the conditions (CQ1) - (CQ4) in the case of the classical client and a single quantum server. However, if the setting of a single quantum device is lifted to allow for multiple quantum devices in a protocol, the conditions are shown to be fulfilled by several schemes. In other words, settings involving at least two quantum devices: either a user with some quantum capabilities and a remote quantum server or two or more entangled but non-communicating servers with a classical client satisfy all the four conditions. In the latter scenario, the first scheme was introduced in~\cite{reichardt2013classical} which allows a classical client to delegate a quantum computation with the help of two entangled but non-communicating servers. Similar results were shown in~\cite{mckague2013interactive}, using a polynomial number of the entangled but non-communicating server. Although the main purpose of the papers was to propose a scheme for verification of quantum computation for a completely classical client, it also shows the privacy of the computation along the way provided that the servers do not communicate.
 
We consider the former case when the client has the ability to perform a part of the quantum computation.  There has been tremendous progress on this front and we detail some of it in the next section.

\subsubsection{Semi-classical client - quantum server}
In the literature, delegated quantum computing protocols with a semi-classical client and a universal quantum server that allows for privacy of the computation, as well as the input and the output, are known as \emph{blind} quantum computing protocols and protocols that allow for correctness to be ensured with high probability are known as \emph{verifiable} quantum computing protocols. The first blind quantum computing protocol was proposed by Childs~\cite{childs2005secure}. Although the scheme allows a client with restricted quantum capabilities to perform universal quantum computation in a secure fashion, the scheme put a rather heavy burden on the client's side in terms of resources. Specifically, the client is required to control a quantum memory and to perform SWAP gates. Subsequently, Arrighi and Salvail~\cite{arrighi2006blind}, building upon the ideas of Feigenbaum~\cite{feigenbaum1985encrypting}, proposed mechanisms for both verification and blindness for a limited range of functions. In this work, the client is required to both generate the superpositions of multi-qubit states as well as perform a family of multi-qubit measurements. The first work to capture the unconditional security definitions and allow the client to delegate a universal quantum computation with minimal resource requirement was introduced by Broadbent, Fitzsimons, and Kashefi in~\cite{broadbent2009universal}. This was further developed into a universal scheme for verifiable blind quantum computation by Fitzsimons and Kashefi in \cite{fitzsimons2017unconditionally}. Hereafter, we refer to these protocols as the BFK and the FK protocol (after the name of the authors). In both the BFK and the FK protocol, a client, Alice, with limited quantum capabilities carries out a quantum computation with the help of a (potentially untrustworthy) server, Bob. The protocol is blind if Alice's input, output, and computation are hidden from Bob and it is verifiable when Alice has exponentially small (in terms of a security parameter) probability of accepting an incorrect output from Bob. The definitions of blindness in the stand-alone setting and composable setting is mentioned in Definition~\ref{def:secbqc} and Definitions.~\ref{def:cssecbqc}, respectively. \textcolor{blue}{Need to add composable definition..}

The problem of blind and verifiable quantum computing from the context of interactive proof systems was considered by Aharonov \emph{et~al.}~\cite{aharonov2008interactive, aharonov2017interactive}, who considered the use of a constant-sized quantum computer to verify a larger device and studied quantum prover interactive proof systems by extending the quantum authentication schemes~\cite{barnum2002authentication}. Subsequent work by Broadbent~\cite{broadbent2015verify} reduced the requirements on the prover to mirror those used in the BFK protocol. Morimae and Fujii proposed a blind quantum computing protocol in~\cite{morimae2012blind}, which unlike all the previous setting allows the client to perform measurements instead of a single qubit preparation. This setting of MF has also been investigated for the verifiable blind quantum computing (\textcolor{blue}{more details in the next chapter}), where the client either performs the target computation or test the server's operation in~\cite{morimae2014verification,hayashi2015verifiable,hayashi2016self, takeuchi2018verification, takeuchi2018resource}.  Using the Raussendorf-Harrington-Goyal scheme~\cite{raussendorf2006fault, raussendorf2007fault, raussendorf2007topological}, same authors (Morimae and Fujii) have also proposed a fault-tolerant blind quantum computation scheme in~\cite{morimae2012blind}.
 
Over the last few years, the blind quantum computing schemes have been optimised~\cite{mantri2013optimal, giovannetti2013efficient, perez2015iterated}, investigated in different physical systems~\cite{morimae2012continuous, dunjko2012blind, liu2018client} and extended to the device independent setting~\cite{hajdusek2015device, gheorghiu2015rigidity, coladangelo2017verifier}. Almost all of the proposed protocols are both blind and verifiable, however it is possible to perform verification without hiding any information about the input or computation, from the server. In fact, Ref.~\cite{fitzsimons2018post, mahadev2018classical} introduces verifiable computing schemes that are not naturally blind. 

Some of the theoretical schemes have also been implemented in (quantum optics) experiments~\cite{barz2012demonstration, barz2013experimental, greganti2016demonstration}. We refer the readers to some of a recent review paper~\cite{fitzsimons2016private} and references therein for more details on the subject of secure delegated quantum computing.

\subsection{Example}
To provide the readers with a flavor of blind quantum computing, we give a brief outline of the BFK protocol and describe the main idea without going into the details of the security argument.

\subsubsection{The Broadbent-Fitzsimons-Kashefi protocol}
\label{sec:bfk}
The Broadbent-Fitzsimons-Kashefi (BFK) protocol is an interactive protocol based on the measurement-based quantum computation. Here, a client augmented with the ability to prepare and send single-qubit quantum states interacts with a universal quantum server to perform their desired quantum computation securely.  Consider a client, Alice, who would like to compute a unitary $U$ on her input state $|I\rangle$ to get her desired output state $U |I\rangle$.  Equivalently, we can also denote computation in the measurement-based model with a measurement pattern consisting of a graph $\mathcal{G}$, and a set of measurement angles, $\vec \phi$, in the XY-plane. For simplicity, the flow is assumed to be from left to right and known to both the parties. Therefore, the graph dimension $(n,m)$ and the angles $\vec \phi$ are the only protocol parameters. The steps of the protocol (in the case of quantum input) are shown below:
\begin{enumerate}
\item Alice prepares an $n$-qubit input state $|I\rangle$ and $n(m - 1)$ auxiliary qubits in the quantum state $|+\rangle$, where $|+\rangle \coloneqq \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$. All the qubits are quantum one-time padded and the encrypted state is written in the following way:
\begin{align}
|\psi' \rangle &=\big( X^{x_{1}}R_Z(\theta_1) \otimes  \dotsc \otimes X^{x_{n}}R_Z(\theta_n) \otimes R_Z(\theta_{n+1}) \otimes \cdots \\ \nonumber
& \cdots \otimes R_Z(\theta_{nm}) \big) | I\rangle \otimes  |+\rangle^{\otimes{n(m-1)}} 
\end{align}
where $\vec x \coloneqq (x_1, \dotsc, x_n)$ is a $n$-bit string with each $x_i$ randomly chosen from $\{0,1\}$, and a set of angles $\vec \theta \coloneqq (\theta_1, \dotsc, \theta_nm)$ with the angle $\theta_i$ uniformly randomly chosen from the angle set $\mathcal{A} = \{k\pi/4\}_{k=0}^{7}$. The $n$-bit string $\vec x$ and $n$ $\theta$'s are used as the key to one-time pad the input state, and an additional $n(m-1)$ $\theta$'s for the one-time pad of the auxiliary states. This is because $R_Z(\theta)$ is sufficient to one-time pad the quantum states $|+\rangle$. Alice sends the state $|\psi'\rangle$ to Bob. 
\item Bob receives all the quantum states and generate the graph state $\mathcal{G}_{n \times m}$ as agreed upon. 
\item Alice computes an angle $\delta$ using the following relation:
\begin{equation}
\delta = \phi' + \theta + r\pi
\end{equation}
where the angle $\delta \in \mathcal{A}$. When~$1 \leq i \leq n$, Alice updates the angle $\phi_i' = (-1)^{s_i^{X}\oplus x_i}\phi_i + s_i^{Z}\pi$  and when~$(n+1) \leq i \leq m $, Alice updates the angle $\phi_i' = (-1)^{s_i^{X}}\phi_i + s_i^{Z}\pi$, depending on the dependency set $s^{X}$ and $s^{Z}$ which can be calculated using the flow construction (Definition~\ref{def:flow}). Here, $x_{i}$ is the bit corresponding to the Pauli-X gate in the one-time pad and $\phi$ denotes the measurement angle for the positive branch of the computation. The random variables $\theta \in_{\mathbb{R}} \mathcal{A}$ and  $r \in_{\mathbb{R}} \mathbb{Z}_{2}$ are chosen uniformly random. Alice sends the classical message encoding the angle $\delta$ to Bob.
\item Bob receives the classical message and performs a projective measurement on the graph state in the basis $\{|+_\delta\rangle, |-_\delta\rangle\}$ and receives the measurement outcome $b'$ and transmits it to  Alice. 
\item Alice receives updates the output $b'$ to $b$ such that $b\coloneqq b'\oplus r $. This step ensures that effect of the one-time pad of the measurement angle is canceled.  
\item Alice and Bob repeats the steps 3-5 until all the qubits are measured except the last layer of the graph, which is sent as it is (in the case of quantum output) or is measured in the X basis (in the case of classical output) and the measurement outcomes are sent to the client.  
\item In the case of quantum output, Alice computes $s^{x}$ and $s^{z}$ and performs the Pauli corrections $Z^{s^{z}_i}X^{s^{x}_i}$ to get the final output state.     
\end{enumerate}
The correctness of the BFK protocol can be reduced to the correctness of the measurement-based quantum computation using the generalised one-bit teleportation circuit identities shown in Fig.~\ref{fig:1bitg}. The BFK protocol is unconditionally secure as per the Definition~\ref{def:secbqc} in the sense that the quantum state at the server's end is a completely mixed state (since the bit string $r$ is unknown to the server).  Furthermore, the classical information received by the server is perfectly random since $\theta$'s are chosen uniformly randomly from the set $\mathcal{A}$.  Hence, the security follows from the security of quantum one-time pad and the fact that Bob is not able to distinguish non-orthogonal states with any advantage than random guessing. The composable security of the BFK protocol (as per the Definition~\ref{def:seccomp}) is shown in~\cite{dunjko2014composable}.


The possibility of performing blind quantum computation with multiple clients, where clients are only required to prepare single qubit states, was first shown in Ref.~\cite{kashefi2016blind}. The setting considered by the authors is the following:  A multiparty delegated quantum computing protocol consists of $n$  clients, who will like to perform a unitary operation $U$ on their input state $\rho$ with the help of a quantum server. All the parties are allowed to have information about the unitary $U$ except the server. The input and output of each client remain private. The results in~\cite{kashefi2016blind} are shown under the assumption of common classical cryptographic constructions. In a similar setting, Ref.~\ref{mantri2019secure} analyse the multi-client protocol in information-theoretic setting provided clients share a classical secure channel and show that an honest client is able to verify in the case server or client deviates from the steps of the protocol. 

In a recent paper~\cite{houshmand2018composable}, the authors examine the multi-client delegated quantum computing problem from a different perspective, where the global unitary is composed of local unitaries that are individually decided by the clients. In this setting, each client's part is kept secret from the server and the other clients (assuming honest client behavior).  Instead of a constructive multi-client scheme, the authors propose a verifiable composable secure multi-client delegated scheme that can be composed of any verifiable composable secure single-client delegated quantum computing protocols and quantum authentication codes. 

The notion of blind quantum computing (with single client) is also extended to the setting of secure two-party quantum computation. In~\cite{kashefi2017garbled}, the authors proposed a quantum Yao protocol, where an honest-but-curious client (also known as sender/garbler) ``garbles" the entire unitary.  The malicious server (also known as user/evaluator), receives instructions from the client and insert their input either using a (classical) oblivious transfer~\cite{rabin2005exchange} or by a quantum input insertion scheme secure against the honest-but-curious client.  The server performs the computation, extracts their own output qubits and returns the remaining output qubits to the client.  The client releases the encryption keys of the server's output qubits after the client verifies the computation. The authors proposed two protocols for such a secure two-party quantum computation: one requires interaction while other is non-interactive in nature. The non-interactive protocol uses the classical hardware primitive such as a \emph{one-time memory}. The idea of replacing the classical interaction assuming the existence of these hypothetical devices was first introduced in~\cite{broadbent2013quantum}.  It seems reasonable to use such a hypothetical hardware device due to the impossibility results to achieve such a program hiding~\cite{broadbent2013quantum, alagic2016quantum}. 
%On the contrary, Ref.~\ref{mantri2019secure} \textcolor{blue}{cite thesis chapter..} present a non-interactive secure two-party computation protocol that is information-theoretic secure by relaxing the deterministic behavior of computation.  

%\comment{To do!}

%
% Circuit Model
%

%\subsection{Circuit model} \index{Encrypted circuit model}

%\comment{To do}

%
% Homomorphic Encryption
%

\subsection{Homomorphic encryption} \index{Homomorphic encryption}
\textcolor{blue}{Merge with the previous chapter/section..}
Study of non-interactive scheme for secure delegation of quantum computation is motivated from a practical point of view, where having no interaction between the client and the server during the processing would be highly preferable. In the line of reducing round complexity, we briefly mention that fully homomorphic encryption (FHE) provide encryption schemes that allow for computing on encrypted data without any interaction between the client and the server during the computation. In recent years, there have been several proposals for homomorphic encryption schemes in classical as well as the quantum setting. On the one hand, similar to (CQ1), (CQ2) and (CQ4) conditions, most of the proposed quantum FHE protocols under the information-theoretic security are shown for either non-universal schemes or provides imperfect security~\cite{tan2016quantum,ouyang2018quantum,lai2017statistically,tan2017practical}. Contrary to the blind quantum computing schemes, there exists results which state that evaluation of arbitrary quantum circuits on encrypted data is impossible with perfect or near-perfect security~\cite{yu2014limitations, newman2017limitations, lai2017statistically}. On the other hand, there have been several proposals ~\cite{broadbent2015quantum, dulek2016quantum, mahadev2017classical, brakerski2018quantum}, with the schemes built on top of classical fully homomorphic encryption schemes and thereby inheriting computational security. In this dissertation, we restrict ourselves to the discussion on information theoretic-security and blind quantum computing schemes. 

\textcolor{blue}{Add remote state preparation with classical client paragraph and references...}

\subsection{Blind quantum computing in the quantum internet era!} 
\textcolor{blue}{Add Hybrid schemes - a paragraph and implementations ..}


\subsection{Other cryptographic derivative...}
\subsubsection{One-time quantum programs} \index{One-time quantum programs}
One-time programs are considered in a two-party setting between a software sender, Alice, and a user, Bob. Such programs are a computational paradigm that allows for a secret function $f$, known only to Alice, to be executed by Bob one and only one choice of input. For any function, $f$ encoded as a one-time program, a user having only one copy of that program may obtain only a single input-output pair $(x, f(x))$ for their choice of $x$.  The one-time programs could be used in applications such as program obfuscation, software protection, electronic cash or token schemes. They were first introduced by Goldwasser, Rothblum and Kalai~\cite{goldwasser2008one}, who showed the construction of a one-time program for any function $f$ using the one-time memory. This was later extended to a more general primitive (which the authors call \emph{non-interactive secure two-party computation}) in~\cite{goyal2010founding}. In fact, this primitive was heavily used in the construction of quantum one-time programs scheme in~\cite{broadbent2013quantum}. We present a formal definition of one-time programs: 

 \begin{definition}
A one-time program, $\tilde{f}(\cdot)$, is a cryptographic primitive, where, in a single round of communication, a user evaluates a function $f$ such that they may only evaluate a single input-output pair $(f(x),x)$. The user must necessarily gain no knowledge of other outputs $f(x') ~\forall~  x' \neq x$ except what can be directly inferred by the user's input-output pair $(f(x),x)$. A program is $\epsilon$-correct if probability $P(\tilde{f}(x)|f(x))$, the probability one-time program $\tilde{f}(x)$ returns the same value as $f(x)$, is $1-\epsilon$.  
\end{definition}

A recent scheme by Roehsner \textit{et al.}~\cite{roehsner2017quantum} shows how to encode arbitrary probabilistic one-time programs with information theoretic security.  Here, the sender first compiles program $f$ into a series of classical logic gates via a process of logic synthesis.  Each of these logic gates is then replaced with a one-time gate (gate-OTP); a one-time program consisting of the single boolean gate with one output bit. Each gate-OTP denoted $G$, is then encoded as a separable state of some number of qubits, the number of which scales linearly in the number of elementary logic gates required to implement $G$. Such qubit states are then provided to Bob via a quantum channel, who evaluates $G$ via measuring each qubit received in a measurement basis corresponding to his input $i$, where $i$ is a $k$-bit string. The probability of any gate-OTP $G$ returning the correct result $G(i)$ is given as $P = \frac{1}{2}+\frac{1}{2^{(1+k/2)}}$. Thus each gate-OTP is equivalent to a single instance of $\binom{2^k}{1}$ noisy oblivious transfer. As a measurement of a quantum state is an irreversible process, the use of mutually anti-commuting operators, $\sigma_i$, ensures only a single evaluation, $G(i)$, of any gate, may be made. The quantum state encoding each gate-OTP is created such that the probable projection of the state under such measurement operations is proportional to the desired gate behavior. For each gate-OTP $G$, the density matrix is given as
 \begin{equation}
\rho_G = \frac{1}{Tr(\mathbb{I})} \left[ \mathbb{I} + \frac{1}{\sqrt{2^k}}\sum _{i=1} ^{2^{k}} (-1)^{G(i)} \sigma_i \right] .
\label{otpeq}
\end{equation}

