%
% Quality of Service
%

\section{Error correction}\index{Quantum error correction (QEC)}\index{Quality of service (QoS)}\label{sec:QOS_chap}

\famousquote{Beware of bugs in the above code. I have only proved it correct, not tried it.}{Donald Knuth}\\

\dropcap{A}{s} with classical networks, quality of service (QoS) is a major consideration in any quantum network, hence the interest in cost vector analysis and optimisation. If we are transmitting quantum states over a quantum channel, there will inevitably be deterioration in the form of decoherence, loss, and other undesirable effects we wish to mitigate. In this section we review some of the essential quantum error correction (QEC) techniques that can positively improve the quality of transmitted quantum states, which do not have direct classical analogues.

For some simple quantum communications protocols, simple error correction (or even no error correction) may suffice. A full-fledged distributed quantum computation on the other hand will require error rates within a fault-tolerance threshold\index{Fault-tolerance!Thresholds}. Different error correcting codes have different error correcting power, and different resource overheads, which must be taken into consideration.

%
% Entanglement Purification
%

%\subsection{Entanglement purification}\index{Entanglement!Purification}
%
%As we will later see in Sec.~\ref{sec:ent_ultimate}, Bell pairs are a ubiquitous resource for many quantum information processing applications, and warrant special treatment in their own right.
%
%Entanglement purification (or distillation) is a process by which two imperfect distributed Bell pairs can be condensed into a single Bell pair of higher quality (as measured by a fidelity metric, Sec.~\ref{sec:fid_metric}).
%
%More concretely, we distribute two Bell pairs of fidelity $F$ between Alice and Bob. Let us assume a bit-flip error model in this instance\footnote{The same protocol can be employed to correct against phase-flip errors by operating in a Hadamard-rotated basis.}, in which case the imperfect Bell pairs are of the form,
%\begin{align}
%\hat\rho^F_{A,B} &= F\ket{\Phi^+}\bra{\Phi^+} + (1-F)\hat{X}_1\ket{\Phi^+}\bra{\Phi^+}\hat{X}_1 \nonumber \\
%&= F\ket{\Phi^+}\bra{\Phi^+} + (1-F)\ket{\Psi^+}\bra{\Psi^+},
%\end{align}
%That is, we have a mixture of,
%\begin{align}
%\ket{\Phi^+} = \frac{1}{\sqrt{2}}(\ket{0}_A\ket{0}_B + \ket{1}_A\ket{1}_B),	
%\end{align}
%with probability $F$, and,
%\begin{align}
%\ket{\Psi^+} = \frac{1}{\sqrt{2}}(\ket{0}_A\ket{1}_B + \ket{1}_A\ket{0}_B),	
%\end{align}
%with probability \mbox{$1-F$}. The goal is to `filter' out the latter of these.
%x 
%Alice and Bob then perform their entanglement purification protocol -- operations to reduce them to a single Bell pair of higher fidelity,
%\begin{align}
%\mathcal{E}_\mathrm{purif}(\hat\rho^{F_\mathrm{in}}_{A,B} \otimes \hat\rho^{F_\mathrm{in}}_{A,B}) \to \hat\rho^{F_\mathrm{out}}_{A,B},
%\end{align}
%where,
%\begin{align}
%F_\mathrm{out}>F_\mathrm{in}.
%\end{align}
%
%The purification process $\mathcal{E}_\mathrm{purif}$ is realised very simply by Alice and Bob both performing parity measurements\index{Bell!Measurements} on their two qubits, whose measurement outcomes indicate whether the two qubits were equal ($+$) or different ($-$) -- their parity. These are easily implemented using CNOT gates, using the construction shown in Fig.~\ref{fig:parity_meas}, which implement the projectors,
%\begin{align}\index{Bell!Measurements}\index{Parity!Projectors}
%\hat\Pi^+ &= \ket{0,0}\bra{0,0} + \ket{1,1}\bra{1,1}, \nonumber \\
%\hat\Pi^- &= \ket{0,1}\bra{0,1} + \ket{1,0}\bra{1,0}.
%\end{align}
%
%They complete the protocol by classically communicating their measurement outcomes, and performing appropriate local corrections.
%
%\begin{figure}[!htbp]
%	\begin{align}
%		\Qcircuit @C=.7em @R=.4em @! {
%		\lstick{} & \qw & \targ & \meter \\
%		\lstick{} & \qw & \ctrl{-1} & \qw
%		} \nonumber
%	\end{align}
%	\captionspacefig \caption{Construction of a parity measurement circuit using a single CNOT gate and a single-qubit measurement. The measurement outcome indicates whether the two input qubits were the same (\mbox{$\ket{0}\ket{0}$}, \mbox{$\ket{1}\ket{1}$}) or different (\mbox{$\ket{0}\ket{1}$}, \mbox{$\ket{1}\ket{0}$}). See Sec.~\ref{sec:bell_proj} for a simple linear optics construction for this operation.}\label{fig:parity_meas}\index{Bell!Measurements}
%\end{figure}
%
%Two such parity projections project a 4-qubit state down to a 2-qubit state. The full circuit for this entanglement purification protocol is shown in Fig.~\ref{fig:ent_purif_circ}.
%
%\begin{figure}[!htbp]
%\includegraphics[clip=true, width=0.39\textwidth]{entanglement_purification}
%\captionspacefig \caption{Protocol for entanglement purification of two noisy Bell pairs (blue) into a single less noisy Bell pair. Not shown are trivial single-qubit local corrections that may need to be made, depending upon measurement outcomes.} \label{fig:ent_purif_circ}\index{Entanglement!Purification}
%\end{figure}
%
%Let us illustrate the operation of the circuit by example of different possible input states.
%
%Suppose there were no errors, the ideal case. Then the input state was,
%\begin{align}
%\ket\psi_\mathrm{in} &= \ket{\Phi^+}_{1,2} \ket{\Phi^+}_{3,4}\\
%&= \frac{1}{2}(\ket{0}_1\ket{0}_2+\ket{1}_1\ket{1}_2)(\ket{0}_3\ket{0}_4+\ket{1}_3\ket{1}_4).\nonumber
%\end{align}
%Upon parity measurement we obtain,
%\begin{align}
%\hat\Pi^+_{1,3} \ket{\Phi^+}_{1,2}\ket{\Phi^+}_{3,4} &= \ket{\Phi^+}_{2,4},\nonumber \\
%\hat\Pi^-_{1,3} \ket{\Phi^+}_{1,2}\ket{\Phi^+}_{3,4} &= \hat{X}_2\ket{\Phi^+}_{2,4},
%\end{align}
%and we obtain the desired output Bell pair (with an $\hat{X}$ correction in the case of the odd-parity outcome).
%
%Note that if both qubits from one Bell pair are subject to bit-flips, this is equivalent to no error, since,
%\begin{align}
%	\hat{X}_1\hat{X}_2\ket{\Phi^+}_{1,2}=\ket{\Phi^+}_{1,2}.
%\end{align}
%
%Now suppose there was a bit-flip error on the first qubit of the first pair. Now the input state is,
%\begin{align}
%\ket\psi_\mathrm{in} &= \hat{X}_1 \ket{\Phi^+}_{1,2} \ket{\Phi^+}_{3,4}\\
%&= \frac{1}{2}(\ket{1}_1\ket{0}_2+\ket{0}_1\ket{1}_2)(\ket{0}_3\ket{0}_4+\ket{1}_3\ket{1}_4).\nonumber
%\end{align}
%Now upon parity measurement we obtain,
%\begin{align}
%\hat\Pi^+_{1,3} \hat{X}_1\ket{\Phi^+}_{1,2} \ket{\Phi^+}_{3,4} &= \hat{X}_2\ket{\Phi^+}_{2,4},\nonumber \\
%\hat\Pi^-_{1,3} \hat{X}_1\ket{\Phi^+}_{1,2} \ket{\Phi^+}_{3,4} &= \ket{\Phi^+}_{2,4},
%\end{align}
%and following correction we achieve a bit-flipped Bell pair.
%
%Finally, with both Bell pairs subject to a single bit-flip,
%\begin{align}
%\ket\psi_\mathrm{in} &= \hat{X}_1\hat{X}_3 \ket{\Phi^+}_{1,2}\ket{\Phi^+}_{3,4} \\
%&= \frac{1}{2}(\ket{1}_1\ket{0}_2+\ket{0}_1\ket{1}_2)(\ket{1}_3\ket{0}_4+\ket{0}_3\ket{1}_4).\nonumber
%\end{align}
%Upon performing the parity measurement,
%\begin{align}
%\hat\Pi^+_{1,3} \hat{X}_1\hat{X}_3\ket{\Phi^+}_{1,2} \ket{\Phi^+}_{3,4} &= \ket{\Phi^+}_{2,4},\nonumber \\
%\hat\Pi^-_{1,3} \hat{X}_1\hat{X}_3\ket{\Phi^+}_{1,2} \ket{\Phi^+}_{3,4} &= \hat{X}_2\ket{\Phi^+}_{2,4},
%\end{align}
%recovering the expected Bell pair, without an erroneous bit-flip.
%
%Evidently, the output Bell pair is subject to an unexpected bit-flip iff one of the Bell pairs was subject to a bit-flip error. This yields the output fidelity,
%\begin{align}
%F_\mathrm{out} = \frac{{F_\mathrm{in}}^2}{{F_\mathrm{in}}^2 + (1-F_\mathrm{in})^2},
%\end{align}
%and thus the purification protocol improves fidelity provided that \mbox{$F_\mathrm{out}>F_\mathrm{in}$}, which implies the input fidelity must satisfy \mbox{$F_\mathrm{in}>1/2$}.

%
% 3-Qubit Code
%

\subsection{3-qubit code}\index{3-qubit code}

The 3-qubit bit-flip code is traditionally used as a basic introduction to the concept of quantum error correction. However, the 3-qubit code \textit{does not} represent a full quantum code. This is due to the fact that the code cannot simultaneously correct for both $X$-errors and $Z$-errors, which is  required for correcting errors for an arbitrary error mapping on a single qubit. This code is a quantum analogue of the classical repetition code.

The 3-qubit code encodes a single logical qubit into three physical qubits with the property that it can correct for a single $X$-error. The two logical basis states $\ket{0}_L$ and $\ket{1}_L$ are defined as,
\begin{align}
\ket{0}_L = \ket{000}, \quad \quad \ket{1}_L = \ket{111},
\end{align}
such that an arbitrary single qubit state $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$ is mapped to,
\begin{align}
\alpha\ket{0} + \beta\ket{1} &\rightarrow \alpha\ket{0}_L + \beta\ket{1}_L \\
&= \alpha\ket{000} + 
\beta\ket{111} = \ket{\psi}_L.
\end{align}

As three individual $X$-errors are required to switch between logical states, $\ket{0}_L \leftrightarrow \ket{1}_L$, any single $X$-error, for example if the encoded state is $\ket{0}_L$. Results in a erred state that is closer to $\ket{0}_L$ than $\ket{1}_L$. The distance between two codeword states, $d$, defines the number of errors that can be corrected, $t$, as, $t = \lfloor(d-1)/2\rfloor$. In this case, $d=3$, hence $t=1$.  

How do we detect and correct errors without directly measuring or obtaining information about the logical state, which would collapse the computational wave-function and destroy the encoded information?  Two additional ancilla qubits, which are used to extract \textit{syndrome} information (information 
regarding possible errors) are introduced.  

Assuming all gate operations are perfect and the only place where the qubits are susceptible to error is the region between encoding and correction, correction proceeds by introducing two ancilla qubits and performing a sequence of CNOT gates, which checks the parity of the three qubits.  

Tab.~\ref{tab:errors} summarises the state of the whole system, for each possible error, just prior to measurement.

\startnormtable
\begin{table}[htbp!]
\begin{center}
\begin{tabular}{|c|c|}
\hline
Error location & Final state, $\ket{\text{data}}\ket{\text{ancilla}}$ \\
\hline \hline
No error & $\alpha\ket{000}\ket{00} + \beta\ket{111}\ket{00}$ \\
Qubit 1 & $\alpha\ket{100}\ket{11} + \beta\ket{011}\ket{11}$ \\
Qubit 2 & $\alpha\ket{010}\ket{10} + \beta\ket{101}\ket{10}$ \\
Qubit 3 & $\alpha\ket{001}\ket{01} + \beta\ket{110}\ket{01}$ \\
\hline
\end{tabular}
\caption{Final state of the five qubit system prior to the syndrome measurement for no error or a single 
$X$ error on one of the qubits. The last two qubits represent the state of the ancilla. Note that each possible error will result in a unique measurement result (syndrome) of the ancilla qubits. This allows for a $X$ correction gate to be applied to the data block which is classically controlled from the syndrome result. At no point during correction do we learn anything about $\alpha$ or $\beta$.} 
\label{tab:errors}
\end{center}
\end{table} 

For each possible situation, either no error or a single bit-flip error, the ancilla qubits are flipped to a unique state based on the parity of the data block. These qubits are then measured to obtain the classical {\em syndrome} result. The result of the measurement will then dictate if an $X$ correction gate needs to be applied to a specific qubit, 
\begin{widetext}
\begin{align}
&\text{Ancilla measurement:} \quad \ket{00}, \quad \text{Collapsed state:} \quad \alpha\ket{000} + \beta\ket{111} \quad \therefore \text{Clean state} \\
&\text{Ancilla measurement:} \quad \ket{01}, \quad \text{Collapsed state:} \quad \alpha\ket{001} + \beta\ket{110} \quad \therefore \text{Bit-flip on qubit 3} \nonumber\\
&\text{Ancilla measurement:} \quad \ket{10}, \quad \text{Collapsed state:} \quad \alpha\ket{010} + \beta\ket{101} \quad \therefore \text{Bit-flip on qubit 2} \nonumber\\
&\text{Ancilla measurement:} \quad \ket{11}, \quad \text{Collapsed state:} \quad \alpha\ket{100} + \beta\ket{011} \quad \therefore \text{Bit-flip on qubit 1} \nonumber
\end{align}
\end{widetext}
Provided that only a single error has occurred, the data block is restored.  

This code will only work if a maximum of one error occurs. If two $X$ errors occur, then the syndrome result becomes ambiguous. For example, if an $X$ error occurs on both qubits one and two, then the syndrome result will be $\ket{01}$. This will cause us to mis-correct by applying an $X$ gate to qubit 3. Therefore, two errors will induce a logical bit flip and causes the code to fail. This flow is illustrated in Alg.~\ref{alg:three_QEC}.

%The first described QEC\index{Quantum error correction (QEC)} code was the 3-qubit code\index{3-qubit code} (or redundancy code) by \cite{bib:Shor95} for redundantly encoding a single logical qubit into three encoded qubits, allowing the detection and correction of at most a single bit-flip error between the encoded qubits. Measurement of the three ancillary qubits yields a \textit{syndrome}\index{Syndromes}, which identifies where the error took place, allowing it to be subsequently corrected with feedforward. This protocol is shown in Alg.~\ref{alg:three_QEC}.

%By switching into a Hadamard-rotated basis, the same code could equivalently correct against at most a single phase-flip error (since \mbox{$\hat{H}\hat{X}\hat{H}=\hat{Z}$}).

\startalgtable
\begin{table}[!htbp]
\begin{mdframed}[innertopmargin=3pt, innerbottommargin=3pt, nobreak]
\texttt{
function ThreeQubitCode($\ket\psi$):
\begin{enumerate}
\item Using two CNOT gates, redundantly encode the logical single-qubit state,
\begin{align}
\ket\psi=\alpha\ket{0}+\beta\ket{1},
\end{align}
into the 3-qubit state,
\begin{align}
\ket\psi_R &= \hat{\mathrm{CNOT}}_{1,2}\hat{\mathrm{CNOT}}_{1,3}\ket\psi\ket{00} \nonumber \\
&= \alpha\ket{000}+\beta\ket{111}.
\end{align}
\item Independently apply bit-flip channels $\mathcal{E}_X$ to each of the three encoded qubits.
\item If exactly one bit-flip operation was applied in total, the three possible erroneous encoded states are,
\begin{align}
\ket\psi_1 &= \hat{X}_1 \ket\psi_R = \alpha\ket{001}+\beta\ket{110}, \nonumber \\
\ket\psi_2 &= \hat{X}_2 \ket\psi_R = \alpha\ket{010}+\beta\ket{101}, \nonumber \\
\ket\psi_3 &= \hat{X}_3 \ket\psi_R = \alpha\ket{100}+\beta\ket{011}.
\end{align}
\item Determine the parity of each of the three pairs of encoded qubits.
\item Assuming at most a single bit-flip operation has occurred on the encoded state, the three parity outcomes uniquely determine which encoded qubit the bit-flip was applied to.
\item Apply classically-controlled bit-flip recovery operations, $\mathcal{R}$, to correct the encoded state, recovering $\ket\psi_R$.
\item Apply the inverse of the encoding operation to recover $\ket\psi$.
\item $\Box$
\end{enumerate}}
\begin{align}
\Qcircuit @C=1.3em @R=.6em {
  & \lstick{\ket{\psi}} & \ctrl{2} & \gate{\mathcal{E}_X}  & \qw & \qw              & \ctrl{3}  & \qw       & \ctrl{4} & \qw & \multigate{2}{\ \mathcal{R}\ } & \qw \\
  & \lstick{\ket{0}}    & \targ    & \gate{\mathcal{E}_X}  & \qw & \qw              & \ctrl{2}  & \ctrl{2}  & \qw      & \qw & \ghost{\ \mathcal{R}\ } \qw & \qw \\
  & \lstick{\ket{0}}    & \targ    & \gate{\mathcal{E}_X}  & \qw & \qw              & \qw       & \ctrl{2}  & \ctrl{3} & \qw & \ghost{\ \mathcal{R}\ } \qw & \qw \\
  &          &          &          & & \lstick{\ket{0}} & \targ \qw & \qw       & \qw      & \meter & \control \cw \cwx \\
  &          &          &          & & \lstick{\ket{0}} & \qw       & \targ \qw & \qw      & \meter & \control \cw \cwx \\
  &          &          &          & & \lstick{\ket{0}} & \qw       & \qw       & \targ    & \meter & \control \cw \cwx
} \nonumber
\end{align}
\end{mdframed}
\captionspacealg \caption{3-qubit code for protecting against at most a single logical bit-flip error. The doubly-controlled CNOT gates represent parity measurements, \mbox{$n_3=n_1\oplus n_2$}, where $n_i$ represents the value of the $i$th qubit. In a Hadamard-rotated basis, the same circuit may be employed to protect against a single phase-flip error. And by concatenating the two we obtain a 9-qubit code protecting against a single depolarising error (i.e joint bit-flip/phase-flip), which is a universal single-qubit error model.} \label{alg:three_QEC}
\end{table}

%
% 9-Qubit Code
%

\subsection{9-qubit code}\index{9-qubit code}

The nine qubit error correcting code was first developed by Shor~\cite{bib:S95} in 1995 and is based on the 3-qubit repetition code. The Shor code can correct a logical qubit from one discrete bit-flip, one discrete phase-flip or one of each on any of the nine physical qubits and is therefore sufficient to correct for any continuous linear combination of errors on a single qubit.  

The two logical basis states for the code are,
\begin{equation}
\begin{aligned}
\ket{0}_L = \frac{1}{\sqrt{8}}(\ket{000}+\ket{111})(\ket{000}+\ket{111})(\ket{000}+\ket{111}), \\
\ket{1}_L = \frac{1}{\sqrt{8}}(\ket{000}-\ket{111})(\ket{000}-\ket{111})(\ket{000}-\ket{111}). \\
\end{aligned}
\end{equation}

Correction for $X$-errors occurs by treating each block of three qubits in the code identically to the three qubit code. Phase errors ($Z$-errors) are corrected by examining the sign differences between the three blocks.  

\begin{table}[!htbp]
\begin{mdframed}[innertopmargin=3pt, innerbottommargin=3pt, nobreak]
\texttt{
function NineQubitCode($\ket\psi$):
\begin{enumerate}
\item Using eight CNOT gates and three Hadamards, redundantly encode the logical single-qubit state,
\begin{align}
\ket\psi=\alpha\ket{0}+\beta\ket{1},
\end{align}
into the 9-qubit state,
\begin{align}
& \ket\psi\ket{00000000} \rightarrow \ket\psi_R \\
&= \frac{\alpha}{\sqrt{8}}(\ket{000}+\ket{111})(\ket{000}+\ket{111})(\ket{000}+\ket{111}) \nonumber \\
& + \frac{\beta}{\sqrt{8}}(\ket{000}-\ket{111})(\ket{000}-\ket{111})(\ket{000}-\ket{111}) \nonumber
\end{align}
\item Independently apply both bit-flip channels $\mathcal{E}_X$ and phase-flip channels $\mathcal{E}_Z$
to each of the three encoded qubits.
\item The nine qubit code is degenerate, meaning that multiple single qubit errors have the same effect on the code-state.  For all possible single qubit phase errors , there are only three possible changes to the logic state.
\begin{align}
\ket\psi_1 &= \hat{Z}_{1,2,3} \ket\psi_R \\
&= \frac{\alpha}{\sqrt{8}}(\ket{000}-\ket{111})(\ket{000}+\ket{111})(\ket{000}+\ket{111}) \nonumber \\
& + \frac{\beta}{\sqrt{8}}(\ket{000}+\ket{111})(\ket{000}-\ket{111})(\ket{000}-\ket{111}) 
, \nonumber \\
\ket\psi_2 &= \hat{Z}_{4,5,6} \ket\psi_R \nonumber \\
&= \frac{\alpha}{\sqrt{8}}(\ket{000}+\ket{111})(\ket{000}-\ket{111})(\ket{000}+\ket{111}) \nonumber \\
& + \frac{\beta}{\sqrt{8}}(\ket{000}-\ket{111})(\ket{000}+\ket{111})(\ket{000}-\ket{111}) 
, \nonumber \\
\ket\psi_3 &= \hat{Z}_{7,8,9} \ket\psi_R \nonumber \\
&= \frac{\alpha}{\sqrt{8}}(\ket{000}+\ket{111})(\ket{000}+\ket{111})(\ket{000}-\ket{111}) \nonumber \\
& + \frac{\beta}{\sqrt{8}}(\ket{000}-\ket{111})(\ket{000}-\ket{111})(\ket{000}+\ket{111}).\nonumber
\end{align}
\item Correct all $X$-errors by applying the three qubit correction protocol to each of the three block.
\item To check for $Z$-errors, compare the $\pm$ signs between blocks by first coupling all qubits in 
blocks one and two via CNOT gates to one ancilla and all qubits in blocks two and three to a second ancilla.
\item To correct for $Z$-errors, apply a physical $Z$-gate to any of the physical qubits in a block identified by the 
ancilla measurements (for a degenerate code, the correction gate does not need to be identical to the original error).
\item $\Box$
\end{enumerate}}
\end{mdframed}
\captionspacealg \caption{9-qubit code for protecting against at most a single bit- and/or phase-flip error. The code is a concatenation of three blocks of three bit-flip codes. Bit-flips are corrected within blocks of three qubits, while phase-flips are corrected by comparing blocks.} \label{alg:nine_QEC}
\end{table}

The nine qubit code is effectively a concatenation of two bit-flip codes. By combining three bit-flip encoded qubits into a 
second level encoded qubit, the lower level codes can correct for a single bit-flip error in any single block, while the 
upper level code corrects for a single phase flip error in any single block. 

Note that a phase flip on {\em any} one qubit in a block of three has the same effect, this is why the 9-qubit 
code is referred to as a degenerate code.  In other error correcting codes, such as the 5- or 7-qubit codes~\cite{bib:S96,bib:LMPZ96}, there is a one-to-one 
mapping between correctable errors and unique states, in degenerate codes such as this, the mapping is not unique.  If we know which block the error occurs it does not matter which qubit we apply the correction operator.  

Even if a bit {\em and} phase error occurs on the same qubit (i.e. a $Y$-error), the $X$ correction circuit will detect and correct for 
bit flips while the $Z$ correction circuit will detect and correct for phase flips.  The $X$-error correction 
has the ability to correct for up to three individual bit flips (provided each bit flip occurs in a different block of three).  However, in general 
the 9-qubit code is only a single error correcting code as it cannot handle more than a single bit flip error if they occur in certain locations.

%By taking two instances of the 3-qubit code, one implementing bit-flip correction and the other implementing phase-flip correction, and concatenating them, we can define a 9-qubit code, which protects against at most a single bit-flip and a single phase-flip. Joint protection against both the bit-flip and phase-flip operators ($\hat{X}$ and $\hat{Z}$) in turn allows error correction against a single depolarising error, the most general type of logical error, which completely destroys a single qubit.

%This is the simplest construction of a code which protects against a single depolarising event. But it is not the most efficient, and numerous more resource-savvy codes for protecting against Pauli errors exist, such as Steane's 7-qubit code\index{Steane code} \cite{bib:SteaneCode}.

%
% Stabiliser Codes
%

\subsection{Stabiliser codes}\index{Stabiliser!Codes}\label{sec:stab_code}

So far we have presented error correcting codes from the perspective of their state representations and their preparation and correction circuits. This is a rather inefficient method for describing the codes as the state representations and circuits clearly differ from code to code. The majority of error correcting codes that are used within the literature are members of a class known as stabiliser codes. Stabiliser codes are very useful to work with. The general formalism applies broadly and there exists general rules to construct preparation circuits, correction circuits and fault-tolerant logical gate operations once the stabiliser structure of the code is specified.  

The stabiliser formalism, first introduced by  Gottesman \cite{bib:G97+}, uses essentially the Heisenberg representation for quantum mechanics which describes quantum states in terms of operators rather that the basis states themselves.  An arbitrary state $\ket{\psi}$ is defined to be stabilised by some operator, $K$, if it is a 
$+1$ eigenstate of $K$,
\begin{align}
K\ket{\psi} = \ket{\psi}.
\end{align}
For example, the single qubit state $\ket{0}$ is stabilised by the operator $K = \sigma_z$,
\begin{align}
\sigma_z\ket{0} = \ket{0}.
\end{align}
Defining multi-qubit states with respect to this formalism relies on the group structure of multi-qubit operators.  

Within the group of all possible, single qubit operators, there exists a subgroup, denoted the Pauli group, $\mathcal{P}$, which contains the following elements,
\begin{align}
\mathcal{P} = \{\pm 1,\pm i\} \times \{\sigma_I, \sigma_x, \sigma_y, \sigma_z\}.
\end{align}
It is easy to check that these matrices form a group under multiplication through the commutation and anti-commutation rules for the Pauli matrices $\sigma_i$,
\begin{align}
[\sigma_i,\sigma_j] &= 2i\epsilon_{ijk}\sigma_k,\nonumber\\
\{\sigma_i,\sigma_j\} &= 2\delta_{ij},
\end{align}
where,
\begin{align}
\epsilon_{ijk} = \Bigg \{
\begin{array}{l}
+1\text{ for } (i,j,k) \in \{(1,2,3), (2,3,1), (3,1,2)\}\\
-1 \text{ for } (i,j,k) \in \{(1,3,2), (3,2,1), (2,1,3)\}\\
0 \text{    for } i=j, j=k, \text{ or } k=i
\end{array}
\end{align}
and
\begin{align}
\delta_{ij} = \Bigg \{
\begin{array}{cr}
1\text{ for } i = j\\
0 \text{ for } i \neq j.
\end{array}
\end{align}
The Pauli group extends over $N$-qubits by simply taking the $N$ fold tensor product of $\mathcal{P}$, i.e.
\begin{align}
\mathcal{P}_N &= \mathcal{P}^{\otimes N}.
\end{align}
An $N$-qubit stabiliser state, $\ket{\psi}_N$ is then defined via an $N$-element Abelian subgroup, $\mathcal{G}$, of the $N$-qubit Pauli group, in which $\ket{\psi}_N$ is a $+1$ eigenstate of each element, 
\begin{align}
\mathcal{G} = \{\; G_i \;|\; G_i\ket{\psi} = \ket{\psi}, \; [G_i,G_j] = 0 \; \forall \; (i,j) \} \subset \mathcal{P}_N.
\label{eq:stabdef}
\end{align}
Given this definition, the state $\ket{\psi}_N$ can be equivalently defined either through the state vector representation {\em or} by specifying the stabiliser set, $\mathcal{G}$.

Many extremely useful multi-qubit states are stabiliser states, including two-qubit Bell states, Greenberger-Horne-Zeilinger (GHZ) states \cite{GHZ89,GHSZ90}, cluster states \cite{BR01,RB01} and codeword states for QEC. As an example, consider a three qubit GHZ state, defined as,
\begin{align}
\ket{\text{GHZ}}_3 = \frac{\ket{000} + \ket{111}}{\sqrt{2}}.
\end{align}
This state can be expressed via any three linearly independent elements of the $\ket{\text{GHZ}}_3$ stabiliser group for example,
\begin{align}
G_1 &= \sigma_x\otimes \sigma_x \otimes \sigma_x \equiv XXX, \nonumber\\
G_2 &= \sigma_z\otimes \sigma_z \otimes \sigma_I \equiv ZZI, \nonumber\\
G_3 &= \sigma_I \otimes \sigma_z \otimes \sigma_z \equiv IZZ,
\end{align}
where the right-hand side of each equation is the short-hand representation of stabilisers. Note that these three operators form an Abelian group as,
\begin{align}
[G_i,G_j]\ket{\psi} &= G_iG_j\ket{\psi} - G_jG_i\ket{\psi} \nonumber\\
&= \ket{\psi}-\ket{\psi} = 0, \quad \forall \quad [i,j,\ket{\psi}].
\end{align}
Similarly, the four orthogonal Bell states,
\begin{align}
\ket{\Phi^{\pm}} &= \frac{\ket{00} \pm \ket{11}}{\sqrt{2}}, \\
\ket{\Psi^{\pm}} &= \frac{\ket{01} \pm \ket{10}}{\sqrt{2}},
\end{align}
are stabilised by the operators, $G_1 = (-1)^aXX$, and $G_2 = (-1)^b ZZ$. Where $[a,b] \in \{0,1\}$ and each of the four Bell states correspond to the four unique pairs, $\{\Phi^+,\Psi^+,\Phi^-,\Psi^-\} = \{ [0,0],[0,1],[1,0],[1,1]\}$.  
 
%\subsection{QEC with stabiliser codes}
%\label{sec:sec:QEC2}

The use of the stabiliser formalism to describe quantum error correction codes is extremely useful since it allows for easy synthesis of correction circuits and also clearly shows how logical operations can be performed directly on encoded data. As an introduction we will focus on arguably the most well known quantum code, the 7-qubit Steane code \cite{bib:S96}.  

The 7-qubit code represents a full quantum code that encodes seven physical qubits into one logical qubit, with the ability to correct for a single $X$ and/or $Z$ error. The $\ket{0}_L$ and $\ket{1}_L$ basis states are defined as,
\begin{widetext}
\begin{align}
|0\rangle_L = \frac{1}{\sqrt{8}}(&|0000000\rangle + |1010101\rangle + |0110011\rangle + |1100110\rangle + 
|0001111\rangle + |1011010\rangle + |0111100\rangle + |1101001\rangle),\nonumber\\
|1\rangle_L = \frac{1}{\sqrt{8}}(&|1111111\rangle + |0101010\rangle + |1001100\rangle + |0011001\rangle + 
|1110000\rangle + |0100101\rangle + |1000011\rangle + |0010110\rangle).
\label{eq:log}
\end{align}
\end{widetext}
The stabiliser set for the 7-qubit code is fully specified by the six operators,
\begin{align}\label{eq:stab7}
K^1 &= IIIXXXX, \nonumber\\
K^2 &= XIXIXIX, \nonumber\\ 
K^3 &= IXXIIXX, \nonumber\\
K^4 &= IIIZZZZ, \nonumber\\
K^5 &= ZIZIZIZ, \nonumber\\
K^6 &= IZZIIZZ.
\end{align}

As the 7-qubit codeword states are specified by only six stabilisers, the code contains two basis states, which are the logical states.  With a final operator, $K^7 = ZZZZZZZ=Z^{\otimes 7}$ fixing the state to one of the codewords, $K^7\ket{0}_L = \ket{0}_L$ and $K^7\ket{1}_L = -\ket{1}_L$. The 7-qubit code is defined as a $[[n,k,d]] = [[7,1,3]]$ quantum code, where $n=7$ physical qubits encode $k=1$ logical qubit with a distance between basis states $d=3$, correcting $t = (d-1)/2 = 1$ error.  Notice that the stabiliser set separates into $X$ and $Z$ sectors which defines the code as a Calderbank-Shor-Steane (CSS) code. CSS codes are extremely useful since they allow for straightforward logical gate operations to be applied directly to the encoded data and are easy to derive from classical codes.

Although the 7-qubit code is the most well known stabiliser code, there are other stabiliser codes which encode multiple logical qubits and correct for more errors~\cite{bib:G97+}. The downside to these lager codes is that they require more physical qubits and more complicated error correction circuits. Tables \ref{tab:9qubit} and \ref{tab:5qubit} show the stabiliser structure of two other well known codes, the 9-qubit code \cite{bib:S95} which we have examined and the 5-qubit code~\cite{bib:LMPZ96} which represents the smallest possible quantum code that corrects for a single error.  

\startnormtable
\begin{table}[htbp!]
\begin{center}
\vspace*{4pt}   
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
$K^1$ & $Z$&$Z$&$I$&$I$&$I$&$I$&$I$&$I$&$I$ \\
$K^2$ & $Z$&$I$&$Z$&$I$&$I$&$I$&$I$&$I$&$I$ \\
$K^3$ & $I$&$I$&$I$&$Z$&$Z$&$I$&$I$&$I$&$I$ \\
$K^4$ & $I$&$I$&$I$&$Z$&$I$&$Z$&$I$&$I$&$I$ \\
$K^5$ & $I$&$I$&$I$&$I$&$I$&$I$&$Z$&$Z$&$I$ \\
$K^6$ & $I$&$I$&$I$&$I$&$I$&$I$&$Z$&$I$&$Z$ \\
$K^7$ & $X$&$X$&$X$&$X$&$X$&$X$&$I$&$I$&$I$ \\
$K^8$ & $X$&$X$&$X$&$I$&$I$&$I$&$X$&$X$&$X$ \\
\hline
\end{tabular}
\caption{The eight stabilisers for the 9-qubit Shor code, encoding nine physical qubits into one logical qubit to correct for a single $X$ and/or $Z$ error.} 
\label{tab:9qubit}
\end{center}
\end{table} 

\begin{table}[htbp!]
\begin{center}
\vspace*{4pt}   
\begin{tabular}{|c|c|c|c|c|c|}
\hline
$K^1$ & $X$&$Z$&$Z$&$X$&$I$ \\
$K^2$ & $I$&$X$&$Z$&$Z$&$X$ \\
$K^3$ & $X$&$I$&$X$&$Z$&$Z$ \\
$K^4$ & $Z$&$X$&$I$&$X$&$Z$ \\
\hline
\end{tabular}
\caption{The four stabilisers for the $[[5,1,3]]$ quantum code, encoding five physical qubits into one logical qubit to correct for a single $X$ and/or $Z$ error. Unlike the 7- and 9-qubit codes, the $[[5,1,3]]$ code is a non-CSS code, since the stabiliser set does not separate into $X$ and $Z$ sectors.} 
\label{tab:5qubit}
\end{center}
\end{table} 

%\subsubsection{Performing error correction}\label{sec:stabilizer_correction}

Error correction using stabiliser codes is a straightforward extension of state preparation.  Consider an arbitrary single qubit state that has been encoded, 
\begin{align}
\alpha\ket{0} + \beta\ket{1} \rightarrow \alpha\ket{0}_L + \beta\ket{1}_L = \ket{\psi}_L.  
\end{align}
Now assume that an error occurs on one (or multiple) qubits which is described via the operator $E$, where $E$ is a combination of $X$ and/or $Z$ errors over the $N$ physical qubits of the logical state. By definition of stabiliser codes, $K^i\ket{\psi}_L = \ket{\psi}_L$, $i \in [1,..,N-k]$, for a code encoding $k$ logical qubits. Hence the erred state, $E\ket{\psi}_L$, satisfies,
\begin{align}
K^iE\ket{\psi}_L = (-1)^m EK^i\ket{\psi}_L = (-1)^m E\ket{\psi}_L.
\end{align}
where $m$ is defined as, $m=0$, if $[E,K^i]=0$ and $m=1$, if $\{E,K^i\} = 0$. Therefore, if the error operator commutes with the stabiliser, the state remains a $+1$ eigenstate of $K^i$, if the error operator anti-commutes with the stabiliser then the logical state is flips to now be a $-1$ eigenstate of $K^i$.  

Each of the code stabilisers are sequentially measured. Since a error free state is already a $+1$ eigenstate of all the stabilisers, any error which anti-commutes with a stabiliser will flip the eigenstate and consequently the parity measurement will return a result of $\ket{1}$.

Taking the $[[7,1,3]]$ code as an example, if the error operator is $E = X_i$, where $i = (1,\dots,7)$, representing a bit-flip on any {\em one} of the 7 physical qubits, then regardless of the location, $E$ will anti-commute with a unique combination of $(K^4,K^5,K^6)$. Hence the classical results of measuring these three operators will indicate if and where a single $X$ error has occurred. Similarly, if $E=Z_i$, then the error operator will anti-commute with a unique combination of, $(K^1,K^2,K^3)$. Consequently, the first three stabilisers for the $[[7,1,3]]$ code correspond to $Z$ sector correction while the second three stabilisers correspond to $X$ sector correction. Note, that correction for Pauli $Y$ errors are also taken care of by correcting in the $X$ and $Z$ sector since a $Y$ error on a single qubit is equivalent to both an $X$ and $Z$ error on the same qubit, i.e. $Y = iXZ$.  

\subsection{Surface codes}\index{Surface codes}\label{sec:surface_codes}

It has been shown that fault-tolerance is possible within the cluster state model \cite{bib:NielsenDawson04, bib:Dawson06} using variations of conventional QEC codes. However, more importantly, from cluster states certain \textit{topological QEC codes} can be readily constructed. This implements a form of QEC-encoded measurement-based quantum computing protocol, where the computation proceeds in a measurement-based fashion, but is `natively' fault-tolerant.

These codes have been shown to have very favourable fault-tolerance thresholds in terms of both depolarising noise and loss \cite{bib:StaceBarrettDohertyLoss, bib:BarrettStaceFT}, as well as frugal resource overhead compared to traditional concatenated codes. Additionally, loss- and gate-failure-tolerant codes, uniquely applicable to the cluster state model, have been described, with very favourable loss thresholds \cite{bib:Varnava05, bib:RalphHayes05, bib:Duan05}. 

Importantly, topological codes do not require joint measurements across the entire graph state, instead requiring only operations localised to small regions within the graph. Thanks to this, computation using such topological codes can remain distributed\index{Distributed quantum computation} without requiring the entire state to be held locally by a particular host, or requiring full access to the entire state by any particular user. As with cluster states, a large graph can be stitched together from a patchwork of smaller neighbouring graphs.

The most common topological code, which we will use here as an example, is the toric code\index{Toric code}, which resides on a lattice graph over the surface of a torus\footnote{As with cluster states, this graph needn't (but could) correspond to a network graph.}. As with cluster states (Sec.~\ref{sec:CSQC}), the toric code is most easily visualised in the stabiliser formalism\index{Stabiliser!Formalism}, and the toric code is an example of a stabiliser code\index{Stabiliser!Codes} (Sec.~\ref{sec:stab_code}). Consider a rectangular sub-graph of the torus. We place a qubit on each edge (not vertex) of the graph. Now we define two sets of stabiliser operators: \textit{star} ($\hat{S}_+$) and \textit{plaquette} ($\hat{S}_\square$) operators,
\begin{align} \index{Surface codes!Stabilisers}\index{Star operator}\index{Plaquette operator}
	\hat{S}_+(v) &= \prod_{i\in e(v)} \hat{X}_i, \nonumber \\
	\hat{S}_\square(p) &= \prod_{i\in e(p)} \hat{Z}_i,
\end{align}
where $e(v)$ are the edges neighbouring vertex $v$, and $e(p)$ are the edges surrounding plaquette $p$. By definition, the toric code state, $\ket\psi_\mathrm{toric}$, satisfies the stabiliser relations,
\begin{align}
	\hat{S}_+(v) \ket\psi_\mathrm{toric} &= \ket\psi_\mathrm{toric} \,\forall\, v, \nonumber \\
	\hat{S}_\square(p) \ket\psi_\mathrm{toric} &= \ket\psi_\mathrm{toric} \,\forall\, p.
\end{align}
The stabilisers can be visualised graphically as per Fig.~\ref{fig:toric_code}.

\if 1\doublecol
	\begin{figure}[!htbp]
		\includegraphics[clip=true, width=0.475\textwidth]{torus}\\
		\includegraphics[clip=true, width=0.475\textwidth]{toric_code}
		\captionspacefig \caption{Graph representation of the toric QEC code, and its associated stabilisers. The graph resides on a torus (top), while the physical qubits reside on the embedded lattice (bottom). The star and plaquette stabilisers across all vertices, jointly specify the state of the graph up to two missing degrees of freedom, which encode a single logical qubit. Thus, a logical qubit is encoded jointly across the entire graph, not at any specific vertex. Logical operations are performed via operations following topological paths through the lattice (not shown). The graph may be distributed across multiple hosts for distributed quantum computation.} \label{fig:toric_code}
	\end{figure}
\else
	\begin{figure*}[!htbp]
		\includegraphics[clip=true, width=0.475\textwidth]{torus}
		\includegraphics[clip=true, width=0.475\textwidth]{toric_code}
		\captionspacefig \caption{Graph representation of the toric QEC code, and its associated stabilisers. The graph resides on a torus (left), while the physical qubits reside on the embedded lattice (right). The star and plaquette stabilisers across all vertices, jointly specify the state of the graph up to two missing degrees of freedom, which encode a single logical qubit. Thus, a logical qubit is encoded jointly across the entire graph, not at any specific vertex. Logical operations are performed via operations following topological paths through the lattice (not shown). The graph may be distributed across multiple hosts for distributed quantum computation.} \label{fig:toric_code}
	\end{figure*}
\fi

Unlike the cluster state stabilisers from Eq.~(\ref{eq:CS_stab}), these stabilisers are insufficient to fully characterise a unique quantum state. Rather, there are two unspecified degrees of freedom, which allows for a single qubit to be represented. Modifications of the topology, in the form of holes in the lattice (the genus of the topology), allow larger numbers of qubits to be encoded. Logical operations are implemented by performing sequences of local gates and measurements across topologies over the surface.

The important feature to note is that logical qubits encoded into the toric code do not reside locally at any of the physical qubits in the topology. Rather, they reside jointly across the entire graph, which, like cluster states, might be partitioned across multiple hosts, enabling distributed computation.

Having defined the toric code as such, QEC proceeds in a similar manner to any other stabiliser code -- we measure all the stabilisers, yielding a syndrome\index{Error!Syndrome}, from which we can determine geometrically where errors took place in the graph, which can subsequently be corrected (if below threshold).

The simplest example of error detection is the scenario where a single bit-flip ($\hat{X})$ error has occurred in the graph. Now exactly two plaquette stabilisers (the ones upon which the respective qubit acts) will yield the $-1$ measurement outcome, instead of the expected $+1$ outcome. These two stabilisers will necessarily be neighbouring ones, overlapping at the qubit where the error took place. Thus, using this geometric reasoning, we are able to identify the location of the single $\hat{X}$ error and subsequently correct it. On the other hand, if there were too many errors, it is possible they could conspire against us to create ambiguity in the geometric argument for the location of the errors. The QEC procedure is illustrated in Fig.~\ref{fig:toric_code}.

\begin{figure}[!htbp]
	\includegraphics[clip=true, width=0.3\textwidth]{toric_code_correction}
	\captionspacefig \caption{QEC of a single bit-flip (top) and phase-flip (bottom) error via measuring two overlapping stabilisers. If there is at most one bit- or phase-flip error, as per this graphic, then upon measuring all the star and plaquette stabilisers, only those whose qubits are affected by the error channel will yield the $-1$ measurement outcome, the others all yielding $+1$. Such an error will affect exactly two stabilisers, whose qubit in common must have been the one affected by the respective error, which can subsequently be corrected since the type of the error and its location are known. Thus, in this example, all of the $\hat{S}_+^{(1)}$, $\hat{S}_+^{(2)}$, $\hat{S}_\square^{(1)}$ and $\hat{S}_\square^{(2)}$ stabilisers will yield $-1$ outcomes for the shown $\hat{X}$ and $\hat{Z}$ errors, whereas any of the remaining (not shown) $\hat{S}_k^{(j)}$ will yield $+1$ outcomes, which uniquely specifies where those errors took place.}\label{fig:toric_corr}	
\end{figure}

Importantly, the stabilisers are all defined over geometrically localised neighbourhood regions, and do not require long-range measurements, making this type of code suitable to distributed models for quantum computation, much like cluster states.

Logical operations similarly have geometric interpretations. Most simply, logical Pauli-$\hat{X}$ and -$\hat{Z}$ gates may be implemented by applying chains of local Pauli operations along topological paths, specifically closed loops around the two different axes of the torus (Fig.~\ref{fig:toric_code_paulis}. These topologies may be deformed, provided that they are topologically equivalent to the desired closed loops, hence the name `topological code'. With more qubits and more elaborate gates, similar topological definitions exist for implementing logical gates on encoded qubits.

\begin{figure}[!htbp]
	\includegraphics[clip=true, width=0.475\textwidth]{torus_paulis}
	\captionspacefig \caption{Implementation of logical Pauli-$\hat{X}$ and -$\hat{Z}$ operations on a toric code qubit via the application of a chain of local Paulis. The chains must circumnavigate the torus around either axis. Any path topologically equivalent to such a circumnavigation of the torus is sufficient, enabling paths to bypass defects in the lattice.} \label{fig:toric_code_paulis}
\end{figure}

%\comment{What about the actual computation? Can this still be distributed when we do the topological gates etc?}

%\comment{Figures for thresholds FT and QEC}

%\comment{Explain stabiliser measurement and how this yields error syndromes}

%\comment{Explain logical operations on code}

%\comment{Explain how number of logical qubits can be increased by changing topology}

%\comment{How to convert cluster states to topological codes, or any other way of preparing them. Add discussion of how to perform gates.}

%\comment{Figure for both examples of this -- under and over threshold!}

%\comment{Missing degree of freedom in stabilisers defines qubit. How does topology (genus) relate to number of logical qubits?}

%
% Unitary Error Averaging
%

\subsection{Unitary error averaging} \index{Quantum error correction (QEC)}\index{Unitary!Error averaging}\label{sec:error_averaging}

Aside from the \textit{active} QoS techniques discussed until now, there is also a recently described \textit{passive} technique that requires no feedforward to operate. This technique, called \textit{unitary error averaging} \cite{bib:MarshmanLundRohde}, is formulated specifically in the linear optical context. It is an open question whether it generalises to other models, such as conventional quantum circuits.

Suppose we desire to implement some linear optics unitary network, $\hat{U}_\mathrm{target}$, but our fabrication techniques are imperfect and we instead implement a close approximation to it. How can we overcome this?

\cite{bib:MarshmanLundRohdeRalph} showed that by using an optical fanout\index{Fanout} operation, which splits a set of optical modes equally across multiple sets of modes in a type of redundant encoding\footnote{The optical fanout operation effectively maps single-photon states to W-states (Sec.~\ref{sec:W_state_prep})\index{W-states}.}, and passing each set through an independently manufactured copy of the imperfect unitary, $\tilde{U}_i$, upon performing a fan-in to recombine the modes, and post-selection on detecting all photons in the desired output modes, the output state will behave as if it had evolved through a network given by the arithmetic average of each of the imperfect copies of $\hat{U}_\mathrm{target}$,
\begin{align}
\hat{U}_\mathrm{av} = \frac{1}{M}\sum_{i=1}^M \tilde{U}_i.	
\end{align}
A schematic for the optical circuit is shown in Fig.~\ref{fig:error_av_circuit}.

\begin{figure}[!htbp]
\includegraphics[clip=true, width=0.475\textwidth]{unitary_error_averaging}
\captionspacefig \caption{Protocol for error correction via unitary error averaging. Here our computation resides across \mbox{$N=2$} modes, and there are \mbox{$M=2$} redundant copies of the manufactured unitary, which straightforwardly generalises to arbitrary $M$ and $N$. A fanout operation splits the wave amplitudes from the set of $N$ input modes uniformly across $M$ sets of $N$ modes. Each set of $N$ evolves through an independent copy of the manufactured imperfect unitary, $\tilde{U}_i$. A reverse fanout operation recollects the bundles of modes. Upon post-selecting upon detecting all photons within the first $N$ modes, and none in the other ancillary modes, the state is projected into the subspace as if it had been acted upon by the arithmetic average of the imperfect unitaries. If photons are detected in the error modes, our logical state has effectively suffered photon loss and has been corrupted.} \label{fig:error_av_circuit}	
\end{figure}

Note that the protocol doesn't require that the $M$ instances of the unitary be held locally. They operate independently in parallel and could therefore be distributed, with the independent copies held by entirely different parties in distant locations (Sec.~\ref{sec:error_av_parallel}).\index{Distributed quantum computation}\index{Parallelisation}

The protocol is necessarily non-deterministic, since sometimes photons will be measured in the error modes, signalling that the output state has been projected onto an erroneous subspace. Thus, this is a heralded error correction scheme. When post-selection succeeds we have effectively evolved via the averaged operator, which statistically ought to more closely approximate $\hat{U}_\mathrm{target}$ than individual $\tilde{U}_i$.

%
% Qubit Loss Codes
%

\subsection{Qubit loss codes}\index{Qubit loss!Codes}

More severe than a simple, say, dephasing channel is qubit loss, whereby an entire physical qubit is lost to the environment, effectively tracing it out of the system. Depending on physical architecture, there are two ways in which qubit loss might manifest itself:
\begin{itemize}
\item Located errors\index{Located errors}: We know that a loss occurred and which physical qubit was affected.
\item Unlocated errors\index{Unlocated errors}: We do not know that a physical qubit was lost.
\end{itemize}

These manifestations arise naturally in different architectural contexts. For example, it is relatively easy to look at an atomic qubit to see whether it's still where it should be, whereas observing a photonic qubit typically requires destroying it, making the former vulnerable to located errors and the latter to unlocated errors.

It turns out that the distinction between these two modes of error can have a significant effect on the error correction thresholds of QECs. Specifically, a located error effectively gives us an additional classical bit of information diagnosing that an error took place, which we are not privy to for unlocated errors. This additional bit of information can be exploited by QEC codes to improve thresholds for located errors.

In \cite{bib:RohdeHaselgrove} a derivation of a generalisation of the quantum Hamming bound\index{Quantum Hamming bound} for non-degenerate\footnote{In a non-degenerate code, all correctable errors map the codeword to orthogonal states. For degenerate codes\index{Degenerate codes} multiple distinct errors can map the codeword to the same state. The Hamming bound exploits the non-degeneracy using a counting or `pigeonholing' argument to count correctable errors.} QEC codes\index{Non-degenerate codes} was presented, where the number of located and unlocated errors were treated as independent parameters. They found that for non-degenerate codes the Hamming bound allows exactly twice as many located as unlocated errors. Specifically, for $t_l$ located errors and $t_u$ unlocated errors in an $n$-qubit non-degenerate code encoding $k$ logical qubits, QEC is possible provided that the number of errors satisfied,
\begin{align}
\sum_{i=0}^{t_u + \lfloor t_l/2 \rfloor} \binom{n}{i}3^i 2^k \leq 2^n.
\end{align}

Subsequently, using surface codes \cite{bib:StaceBarrettDohertyLoss} arrived at the similar conclusion that QEC codes are more robust against located than unlocated errors.

%
% Gate Failure Codes
%

\subsection{Gate failure codes}\index{Gate failure codes}

Quantum gates, especially 2-qubit entangling ones in many architectures, can have some non-zero chance of failure. In linear optics this gate non-determinism is an inherent feature of entangling gates like the CNOT. In fact it is provable that such gates cannot be implemented deterministically. With a large number of such gates in a circuit, the probability of them all working drops exponentially with the number of non-deterministic gates, thereby undermining efficiency. Can we overcome this?

In Sec.~\ref{sec:CS_LO} we discuss techniques for performing scalable linear optics quantum computing with non-deterministic gates, within the cluster state formalism\index{Cluster states}. The idea is to construct micro-clusters\index{Micro-cluster states} with redundant dangling bonds, which facilitate multiple bonding attempts to merge smaller clusters into larger ones. Once all the entangling operations have been performed, all that remains is to perform a sequence of single-qubit unitaries and measurements, both of which are deterministic in-principle.

This same approach could be logically generalised to any physical architecture where entangling gates are non-deterministic, but single-qubit operations are deterministic. 

%
% Decoherence-Free Subspaces
%

\subsection{Decoherence-free subspaces}\index{Decoherence-free subspaces}

The QoS techniques discussed previously were based on the notion of performing measurements on quantum systems to project them into subspaces devoid of errors. For example, in the 3-qubit code, measurement of the syndrome qubits projects the encoded state into a subspace where there was either no error, or in which an error occurred whose location is known and may therefore be corrected.

An alternate approach is to encode quantum information into Hilbert spaces which are invariant under a given error model. Such spaces are referred to as \textit{decoherence-free subspaces} (DFSs). In this instance we assume the error model is known, for example a dephasing channel, such that we can choose the appropriate DFS.

To illustrate this idea we will consider encoding a single logical qubit into two physical qubits. The error model we will encode against is a collective $Z$-rotation, where the two physical qubits are subject to perfectly correlated $Z$ errors. This arises naturally in the context of, say, atomic qubits subject to the same external electromagnetic field, and therefore accumulate the associated phase errors in tandem.

A single-qubit $Z$-rotation of angle $\theta$ on the Bloch sphere\index{Bloch sphere} is given by,
\begin{align}
	\hat{Z}(\theta) = e^{i\frac{\theta}{2}\hat{Z}} = \begin{pmatrix}
  e^{i\frac{\theta}{2}} & 0 \\
  0 & e^{-i\frac{\theta}{2}}
\end{pmatrix}.
\end{align}
where $\hat{Z}$ is the usual Pauli phase-flip operator\index{Pauli!Operators} (Sec.~\ref{sec:circuit_model}). This operates on the physical basis states as,
\begin{align}
	\hat{Z}(\theta) \ket{0} &\to e^{i\frac{\theta}{2}}\ket{0}, \nonumber \\
	\hat{Z}(\theta) \ket{1} &\to e^{-i\frac{\theta}{2}}\ket{1}.
\end{align}

Now we employ the encoding for logical basis states,
\begin{align}
\ket{0}_L &\equiv \ket{0}_1\otimes\ket{1}_2,\nonumber \\
\ket{1}_L &\equiv \ket{1}_1\otimes\ket{0}_2,
\end{align}
Note that both logical basis states are invariant under a common $Z$-rotation (the other two physical basis states, $\ket{0}_1\otimes\ket{0}_2$ and $\ket{1}_1\otimes\ket{1}_2$ do not observe this property),
\begin{align}
	\hat{Z}_1(\theta)\hat{Z}_2(\theta)\ket{0}_L &= \ket{0}_L,\nonumber\\
	\hat{Z}_1(\theta)\hat{Z}_2(\theta)\ket{1}_L &= \ket{1}_L.
\end{align}
Thus, when acting on an arbitrary linear combination of these basis states (i.e a logical qubit),
\begin{align}
\ket\psi_L = \alpha \ket{0}_L + \beta\ket{1}_L,
\end{align}
via linearity the logical qubit must also be invariant under the collective error,
\begin{align}
	\hat{Z}_1(\theta)\hat{Z}_2(\theta)\ket\psi_L = \ket\psi_L.
\end{align}
This type of DFS encoding therefore protects a logical qubit against arbitrary, unknown but correlated $Z$-rotations.

The same principle can be logically extended to many other correlated error models. For example, operating in a rotated basis (under a Hadamard transform), one could similarly protect against correlated $X$-rotations using the encoding,
\begin{align}
\ket{0}_L &\equiv \ket{-}_1\otimes\ket{+}_2,\nonumber \\
\ket{1}_L &\equiv \ket{+}_1\otimes\ket{-}_2,
\end{align}
where \mbox{$\ket\pm=\frac{1}{\sqrt{2}}(\ket{0}\pm\ket{1})$}.

This idea, although very simple, is very powerful, since it is a completely passive form of error correction, requiring no syndrome measurements, feedforward or correction operations. It also arises quite naturally in some systems where undesired external fields act roughly uniformly across the physical qubits within a system.

%
% Dynamical Decoupling
%

\subsection{Dynamical decoupling}\index{Dynamical decoupling}

An alternate mechanism by which errors could be introduced into our system is via coupling to an external environment (for example via an electromagnetic field) introducing a persistent evolution of our qubits, which is slow-moving compared to the rate at which the implemented computation is evolving the system. We can model this as a joint system/environment Hamiltonian of the form,
\begin{align}\label{eq:dyn_dec_ham}
\hat{H}_\mathrm{total} = \lambda_\mathrm{comp}\hat{H}_\mathrm{comp} + \lambda_\mathrm{env}\hat{H}_\mathrm{env} + \lambda_\mathrm{int}\hat{H}_\mathrm{int},	
\end{align}
where the different components represent, in order, the Hamiltonians of the: total joint system; quantum computer (or system of interest); environment; interaction between system and environment. We are specifically operating in the regime where \mbox{$\lambda_\mathrm{int}\ll\lambda_\mathrm{comp}$}, such that the computation is the dominant term in the evolution and the environmental coupling can be treated as a small perturbation from the desired evolution.

The goal of dynamical decoupling is to minimise the influence of the system/environment interaction term, $\hat{H}_\mathrm{int}$, by manipulating the system in such a way that this term continuously cancels itself out over time.

Let us illustrate how this can be achieved using a simple example, whereby a single-qubit system couples with an environment which introduces a slow, unknown phase evolution. Discretising time, we can write this phase evolution as a Pauli $Z$-rotation on the Bloch sphere\index{Bloch sphere},
\begin{align}
	\hat{Z}(\theta) = e^{i\frac{\theta}{2}\hat{Z}} = \begin{pmatrix}
  e^{i\frac{\theta}{2}} & 0 \\
  0 & e^{-i\frac{\theta}{2}}
\end{pmatrix},
\end{align}
for some unknown, but small $\theta$. Next we observe that, quite obviously, a $Z$-rotation of angle $\theta$ can be trivially undone by applying another $Z$-rotation of angle $-\theta$, since,
\begin{align}
\hat{Z}(-\theta)\hat{Z}(\theta) = \hat\openone.	
\end{align}

Therefore, if the system/environment coupling introduced an evolution of $\hat{Z}(\theta)$ in the previous unit of time, our goal is to manipulate it into implementing $\hat{Z}(-\theta)$ during the next one. Alas, the environment is beyond our control and we cannot directly order it to reverse direction. We do, however, have complete control over our qubit system, so we will achieve the same outcome by flipping the direction of the Bloch sphere underneath the environments foot, allow it to take a step forward, before flipping it back.

How do we achieve this flip in the Bloch sphere? Simply by using the following identity from the algebra of the Pauli matrices\index{Pauli!Operators},
\begin{align}
\hat{X}\hat{Z}(\theta)\hat{X} = 	\hat{Z}(-\theta).
\end{align}
That is, applying a bit-flip to a qubit, followed by an arbitrary phase-rotation, followed by another bit-flip is equivalent to having taken the same phase-rotation in the reverse direction. Effectively we are tricking the environment into time-reversal!

Now if we proceed for two time-steps, once bit-flipped and another not, we have,
\begin{align}
\underbrace{\hat{Z}(\theta)}_{\mathrm{forward}}\cdot\underbrace{[\hat{X}\hat{Z}(\theta)\hat{X}]}_{\mathrm{reverse}} = \hat\openone,
\end{align}
and the unknown phase-rotation has been eliminated. The sequence is illustrated on the Bloch sphere\index{Bloch sphere} in Fig.~\ref{fig:bloch_sphere_dyn_dec}.

\if 1\doublecol
	\begin{figure}[!htbp]
	\includegraphics[clip=true, width=0.475\textwidth]{bloch_sphere_dyn_dec_long}
	\captionspacefig \caption{Bloch sphere representation of a sequence to dynamically decouple an unknown $\hat{Z}$ rotation from a qubit. (a) Blue dot represents the initial state. (b) The state undergoes an unknown $\hat{Z}(\theta)$ rotation. (c) A bit-flip ($\hat{X}$) flips the Bloch sphere upside down. (d) Waiting for the same time as before such that the same unknown $\hat{Z}$-rotation takes place, the state ends up in its initial state, independent of the $\hat{Z}$-rotation angle $\theta$, but assuming it was the same on both occasions in (b) and (d).} \label{fig:bloch_sphere_dyn_dec}	
	\end{figure}
\else
	\begin{figure*}[!htbp]
	\includegraphics[clip=true, width=\textwidth]{bloch_sphere_dyn_dec}
	\captionspacefig \caption{Bloch sphere representation of a sequence to dynamically decouple an unknown $\hat{Z}$ rotation from a qubit. (a) Blue dot represents the initial state. (b) The state undergoes an unknown $\hat{Z}(\theta)$ rotation. (c) A bit-flip ($\hat{X}$) flips the Bloch sphere upside down. (d) Waiting for the same time as before such that the same unknown $\hat{Z}$-rotation takes place, the state ends up in its initial state, independent of the $\hat{Z}$-rotation angle $\theta$, but assuming it was the same on both occasions in (b) and (d).} \label{fig:bloch_sphere_dyn_dec}	
	\end{figure*}
\fi

The coupling to the external environment and the qubit state needn't be constant over time, but could be time-varying. In this instance, it is essential that the decoupling control sequence of bit-flip operations be much faster than the rate at which both the phase-rotations and computational operation are changing, such that consecutive unknown phase-rotations are approximately equal and thereby almost perfectly cancel. This rapid control sequence is sometimes referred to as `bang-bang' control\index{Bang-bang control}, since we are repeatedly implementing bit-flips at a fast rate. 

As described above, we have merely error corrected a quantum memory. Of course we wish to implement far more sophisticated evolutions. This requires breaking down the computational evolution (given by $\hat{H}_\mathrm{comp}$) into a large number of small, discrete steps. These are interspersed with our bang-bang control sequence so as to continuously remove any phase-errors accumulated during the course of the computation.

Dynamical decoupling extends to all manner of error models, beyond the simple $Z$-error model presented above. They are therefore a very powerful tool in error correction. However, unfortunately they are only naturally suited to continuous evolutions governed by Hamiltonians of the form shown in Eq.~(\ref{eq:dyn_dec_ham}), not to the more common discretised models such as the circuit and cluster state models.

%\comment{References}

%
% Continuous-Variables
%

\subsection{Continuous-variables}\index{Continuous-variables!Quantum error correction}

First CV QEC protocol is the direct analogue of the the qubit redundancy codes. However, the noise models do not correspond to what usually occur in Gaussian systems, namely, thermal noise\index{Thermal!Noise} and loss.

It has been proven that QEC of Gaussian noise on Gaussian states, using only Gaussian operations is impossible \cite{bib:PhysRevLett.102.120501}. It is closely related to entanglement distillation, discusses above. Several approaches have since been developed. 

This no-go theorem does not apply if the initial states are non-Gaussian. One can also encode qubits using non-Gaussian continuous-variable states \cite{bib:PhysRevA.64.012310}. Then error correction can be implemented using Gaussian operations, resulting in a Gaussian state. This protocol is known to be fault tolerant, however, the threshold requirements are quite stringent, such as needing the photon number in the squeezed state to be around 20 \cite{bib:PhysRevA.73.012325}.

Another approach is to error correct on Gaussian states using non-Gaussian operations. Such protocols have been proposed \cite{bib:PhysRevA.67.062320} and demonstrated \cite{bib:xiang2010heralded} for entanglement distillation. It has been shown that CV teleportation and distillation based on noiseless amplification can be combined to error correct Gaussian states against Gaussian noise \cite{bib:PhysRevA.84.022339}, implementable using linear optics and photon counting.
However, it is unclear whether such protocolsc can be made fault tolerant.

% \comment{To do -- can we be a bit more specific about the physical resource requirements and the specific noise models? Specify what Gaussian noise means.}