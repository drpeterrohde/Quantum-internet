%
% Collision Handling & Classical Errors
%

\subsection{Collision handling \& classical errors} \label{sec:collision} \index{Collisions!Handling} \index{Classical errors}

In classical networking, protocols such as Ethernet allow users to simply broadcast data at their leisure and rely on \textit{collision detection} to detect when the broadcasts of multiple users have interfered, signalling that both users ought to retransmit following backoff, to minimise the chances of another collision occurring. While this \textsc{Resend Until Success} approach has certainly proven to be effective in classical networking, in a quantum setting the rules of the game are entirely different.

First, collision detection necessarily requires measuring a communications channel to test whether data has been corrupted. Classical networks typically do this by transmitting a checksum with the data, which is recalculated upon arrival for comparison. This raises the obvious problem that quantum measurements are destructive, which means that testing the integrity of our data destroys it in the process -- the last feature we'd like our network to exhibit! However, to overcome this, in Sec.~\ref{sec:transport} we describe a protocol based on the dual classical/quantum network that allows collision detection without measuring quantum states.

Second, collision detection is not always even allowed at all. If one of Alice's packets was entangled with another (i.e she was communicating an entangled system, where the different subsystems resided in different packets), she would not be able to simply retransmit an identical copy of the corrupted packet, since the entanglement with the other system would have been lost and there are no local operations she can do to recover it.

Alternately, Alice might be a part of a distributed computation, where she didn't prepare the data in the first place. In this instance, the no-cloning theorem\index{No-cloning theorem}\footnote{The no-cloning theorem states that it is impossible to take a completely general, unknown quantum state and prepare an identical copy of it. That is, there is no quantum process\index{Quantum processes} implementing the map \mbox{$\mathcal{E}(\hat\rho\otimes\ket{0}\bra{0}) \to \hat\rho\otimes\hat\rho$} for unknown $\hat\rho$. Note that this result applies when $\hat\rho$ is arbitrary and unknown, but in general needn't apply if restricted to a particular basis, subject to other constraints, or we have \textit{a priori} knowledge of the state. \textit{Proof}:\index{No-cloning theorem!Proof} To see this, consider the unitary evolution \mbox{$\hat{U}\ket\psi\ket{e} = e^{i\alpha(\psi,e)}\ket\psi\ket\psi$}, for some normalised ancillary state $\ket{e}$, where $\alpha$ denotes an irrelevant global phase factor. We have \mbox{$\braket{\psi|\phi}\braket{e|e} = \bra\psi\bra{e}\hat{U}^\dag\hat{U}\ket{\phi}\ket{e} = e^{-i[\alpha(\psi,e)-\alpha(\phi,e)]} \braket{\psi|\phi}^2$}. Since $\ket{e}$ is normalised, this implies \mbox{$|\braket{\psi|\phi}| = |\braket{\psi|\phi}|^2$}, which can only be true if \mbox{$ |\braket{\psi|\phi}|=0$} or \mbox{$ |\braket{\psi|\phi}|=1$}, which does not hold in general for arbitrary states $\ket\psi$ and $\ket\phi$. However, clearly if $\ket\psi$ and $\ket\phi$ are restricted to being equal or orthogonal then this constraint can be satisfied with an appropriate choice of $\hat{U}$, since this corresponds to classical cloning\index{Classical cloning}. This proof applies to unitary evolution. What about generic quantum processes? In that case we merely need to assume that the ancillary state $\ket{e}$ acts on a joint primary/environment system, and the same argument applies.} implies that she cannot, in general, learn what the quantum state was, and therefore would be unable to make a second transmission attempt.

From Alice's point of view, \textsc{Resend Until Success} would clearly work if she was preparing a known state, separable from the other packets. However, collisions on the network caused by her reckless resending would likely corrupt the communications between other parties, leaving them rather ticked off at her.

There are therefore two main approaches to dealing with collisions. First, central planning of all routing could be employed, precisely scheduling all routes \textit{a priori} so as to entirely eliminate any possibility for collisions. Second, if all users in the network were communicating data where packet loss could be tolerated, they could all mutually agree to use the \textsc{Resend Until Success} protocol. This would not require a central authority, and be highly desirable for ad hoc networks. It is important to stress, however, that the latter requires unanimity amongst network participants to function, and the restriction to known, separable states is a major limitation that would prohibit many important uses for quantum networks, such as distributed quantum computation. However, both these approaches are entirely valid in their appropriate context.

In classical TCP all components of data packets are classical and are kept together throughout every stage of transmission. In the quantum case we will instead have a mixture of both quantum and classical data. As mentioned, we will assume that classical communication and computation resources `come for free' (or are at least cheap compared to quantum resources), so there will be a clear disambiguation as to what data is quantum or classical within packets.

As discussed, quantum collision detection is complicated by the fact that measuring quantum data to determine whether it has been corrupted disturbs the quantum state. We address this problem by taking advantage of the duality of the quantum/classical network, discussed in Part.~\ref{part:quant_net}. Because the quantum and classical components of the \textsc{Packets} are synchronised and of equal length (thanks to the \textsc{Padding} field of the \textsc{Packet Header}), and because the same applies to all other \textsc{Packets} on the network, a collision in the quantum data necessarily implies a collision in the classical data, and vice versa. Therefore, by applying regular classical collision detection techniques based on checksums (recall \textsc{Packet Header} contains a \textsc{Checksum} field), we can infer collisions in quantum data without actually measuring it. We refer to this as \textit{indirect collision detection}\index{Indirect collision detection}. This guarantees us the ability to detect when a collision has occurred, in which case both quantum \textit{and} classical data are corrupted, or has not occurred, in which case both quantum and classical data are uncorrupted and the quantum data remains unmeasured. Collision detection is incorporated into the pseudo-code implementation of the \textsc{Transport} layer shown in Alg.~\ref{alg:transport_alg}.

This algorithm could, depending upon implementation, be executed locally on the node currently hosting the \textsc{Packet}, or it could be delegated to a central authority, but with the overhead of additional classical communication.

In instances where corruption or loss of packets cannot be tolerated, a more proactive approach may be applied. To preempt the risk of packet collision, one could introduce \textit{probe packets}\index{Probe packets} -- packets containing only classical data, that query a route ahead to negotiate channel usage for the following proper packet, thereby avoiding collisions. Of course, if an upcoming node is unable to guarantee channel capacity immediately, the packet may need to be stored in quantum memory until the channel is available. Thus, it is important to accommodate for this by ensuring that quantum memory is available in nodes preceding links/nodes where collisions are not guaranteed to be mitigated immediately. Quantum memory will be discussed in Sec.~\ref{sec:memory}.